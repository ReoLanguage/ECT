/*******************************************************************************
 * <copyright>
 * This file is part of the Extensible Coordination Tools (ECT).
 * Copyright (c) 2013 ECT developers. 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * </copyright>
 *******************************************************************************/
package org.ect.codegen.reo2constraints.externaltools;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.ect.codegen.reo2constraints.generator.Keyword;
import org.ect.codegen.reo2constraints.generator.State;
import org.ect.codegen.reo2constraints.generator.StateManager;
import org.sat4j.minisat.SolverFactory;
import org.sat4j.reader.InstanceReader;
import org.sat4j.reader.Reader;
import org.sat4j.specs.IProblem;
import org.sat4j.specs.ISolver;
import org.sat4j.tools.ModelIterator;


public class Sat4JInterface {
	public class Solution extends Object {
		private int sourceIdx;

		public int getSourceIdx() {
			return sourceIdx;
		}

		private int targetIdx;

		Solution(String flow, int dataConstraintIdx, int sourceStateIdx,
				int targetStateIdx) {
			this.sourceIdx = sourceStateIdx;
			this.targetIdx = targetStateIdx;
			this.flow = flow;
			this.dataConstraintIdx = dataConstraintIdx;
		}

		public int getTargetIdx() {
			return targetIdx;
		}

		private String flow;

		public String getFlow() {
			return flow;
		}

		public void setFlow(String flow) {
			if (flow != null && flow.trim().length() == 0) {
				flow = null;
			}
			this.flow = flow;
		}

		private int dataConstraintIdx;

		public int getDataConstraintIdx() {
			return dataConstraintIdx;
		}

		public void setDataConstraint(int dataConstraintIdx) {
			this.dataConstraintIdx = dataConstraintIdx;
		}

		@Override
		public boolean equals(Object obj) {
			if (!(obj instanceof Solution))
				return false;
			Solution sol2 = (Solution) obj;
			return (flow.compareTo(sol2.getFlow()) == 0)
					&& (dataConstraintIdx == sol2.getDataConstraintIdx());
		}

	}

	private HashMap<String, Integer> variableNameNo = new HashMap<String, Integer>();
	private HashMap<Integer, String> variableNoName = new HashMap<Integer, String>();
	private ArrayList<String> dataConstraints = new ArrayList<String>();
	private List<Solution> solutions = new ArrayList<Solution>();
	private Map<String, HashSet<String>> reducedNames=null;
	private String cnf;
	private HashMap<String, String> newOldNames=null;
	private boolean useOrbital = true;
	

	public boolean isUseOrbital() {
		return useOrbital;
	}

	public void setUseOrbital(boolean useOrbital) {
		this.useOrbital = useOrbital;
	}

	public Sat4JInterface(String cnf, HashMap<String, String> condId, Map<String, HashSet<String>>  reducedNames, HashMap<String, String> newOldNames) {
		int last=0;
		if (reducedNames != null) this.reducedNames = reducedNames;
		this.cnf = cnf;
		if (newOldNames != null) this.newOldNames = newOldNames;
		if (condId != null) {
			for (String key:condId.keySet()){
				last++;
				variableNoName.put(last, key);
				variableNameNo.put(key, last);
			}
		}
	}

	public List<Solution> getSolutions() {
		return solutions;
	}

	public ArrayList<String> getDataConstraints() {
		return dataConstraints;
	}

	@SuppressWarnings("unchecked")
	/**TODO: some status reporting     can reduce give answers too????
	 * Reformat the CNF formula generated by Reduce into DIMACS format to be used by Sat4J 
	 * @param cnf : CNF formula
	 * @outputCNFFileName : Output file
	 */
	public void makeCNFDIMACSFile(File outputCNFFile) {
		int last = variableNameNo.size()+1;
		ArrayList<ArrayList<String>> main = new ArrayList<ArrayList<String>>();
		ArrayList<String> tab = new ArrayList<String>();
		String kwand = (useOrbital)?Keyword.SYM_AND:Keyword.AND;
		String kwor =  (useOrbital)?Keyword.SYM_OR:Keyword.OR;
		String[] ors = cnf.split(kwand);
		if (useOrbital) {
			for (String or : ors) {
				boolean add = true;
				String tmp = or.replaceAll("\\(|\\)", "");
				String[] atoms = tmp.split("\\|");
				for (String atom : atoms) {
					if (atom.trim().compareTo("false")==0||atom.trim().compareTo("~true")==0);
					else if (atom.trim().compareTo("true")==0||atom.trim().compareTo("~false")==0){
						add = false;
					}
					else {
						boolean neg = atom.contains(Keyword.SYM_NOT);
						tmp = atom.replaceAll("\\W", "");
						if (tmp.length()>0){
							if (!variableNameNo.containsKey(tmp)) {
								variableNameNo.put(tmp, last);
								variableNoName.put(last++, tmp);
							}
							String newVar = (neg ? "-" : "") + variableNameNo.get(tmp);
							if (!tab.contains(newVar)){
								tab.add(newVar);
							}
						add = add && !isTatalogy(neg, newVar, tab);
						}
					}
				}
				if (add)
					main.add((ArrayList<String>) tab.clone());
				tab.clear();
			}
		}
		else {
		for (String or : ors) {
			String tmp = or.trim(); 
			tmp = tmp.replaceAll("\\(|\\)", "");
			String[] atoms = tmp.split(kwor);
			for (String atom : atoms) {
				String[] temp = atom.split(" ");
				if (temp.length != 3) {
					System.out.println("Error in parsing cnf formula at "
							+ temp);
					return;
				}
				if (!variableNameNo.containsKey(temp[0])) {
					variableNameNo.put(temp[0], last);
					variableNoName.put(last++, temp[0]);
				}
				tab.add((temp[2].equals("0") ? "-" : "")
						+ variableNameNo.get(temp[0]));
			}
			main.add((ArrayList<String>) tab.clone());
			tab.clear();
		}
		}
		System.out.println(variableNameNo);
		saveCNF2File(main, last, outputCNFFile);
	}

	private boolean isTatalogy(boolean neg, String newVar, ArrayList<String> tab) {
		String dual = (neg)?newVar.replace("-", ""):("-"+newVar);
		return tab.contains(dual);
	}

	public HashMap<String, Integer> getVariableNameNo() {
		return variableNameNo;
	}

	/**
	 * Reformat the CNF formula generated by Reduce to be used by Sat4J
	 * 
	 * @param cnf
	 *            : CNF frmula
	 * @last :
	 * @cnfFileName : Output file
	 */
	private void saveCNF2File(ArrayList<ArrayList<String>> tab, int last,
			File cnfFile) {
		try {
			FileWriter fstream = new FileWriter(cnfFile);
			BufferedWriter out = new BufferedWriter(fstream);
			out.write("c test\r\n");
			// Close the output stream
			out.write("c\r\n");
			out.write("p cnf " + last + " " + tab.size() + "\r\n");
			for (ArrayList<String> temp : tab) {
				String res = "";
				for (String s : temp) {
					res += s + " ";
				}
				out.write(res + "0\r\n");
			}
			out.close();
		} catch (Exception e) {
			System.err.println("Error: " + e.getMessage());
		}
	}

	/**
	 * Solves a CNF boolean formula using Sat4J
	 * 
	 * @param cnfFileName
	 *            : The name of cnfFileName
	 */
	public void solveSATFormula(StateManager mgr, File cnfFile,
			Map<String, String> conditionIds, boolean hideFalses,
			boolean hideConditions, boolean showNOFLOWDetaiks) {
		System.out.println("CNF format is written in the file:"+cnfFile.getAbsolutePath());
		ISolver solver = SolverFactory.newDefault();
		ModelIterator mi = new ModelIterator(solver);
		solver.setTimeout(3600); // 1 hour timeout
		Reader reader = new InstanceReader(mi);
		int lcnt = 0;
		try {
			IProblem problem = reader.parseInstance(cnfFile.getAbsolutePath());
			while (problem.isSatisfiable()) {
				int[] model = problem.model();
				++lcnt;
				String temp = replaceNumbersByReoNameInTheModel(model,
						conditionIds, hideFalses, hideConditions);
				temp = validateSolution(temp, showNOFLOWDetaiks);
				System.out.println("Saat4J :" + lcnt + " :" + temp);

				int nxtStateIdx = mgr.getCurrStateIdx();
				/////////////////////if (!mgr.isNOFlow(temp)) {
					State nxtState = mgr.makeNextSate(temp);
					if (nxtState != null) {
						nxtStateIdx = mgr.addNextState(nxtState);
					}
					int condAnswIdx = replaceNumbersByNamesForReduce(model,
							conditionIds);
					Solution sol = new Solution(temp, condAnswIdx,
							mgr.getCurrStateIdx(), nxtStateIdx);
					int redundantSolutionIdx = solutions.indexOf(sol);
					if (redundantSolutionIdx < 0) {
						// saveResults
						solutions.add(sol);
					}
			//	}
			}
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Timeout, sorry!");
		}
	}

	/**
	 * Accepts a model satisfying the CNF formula Returns an string in which the
	 * numbers are replaced by the original names of Reo nodes The names are
	 * separated by a &
	 * 
	 * @param model
	 * @return
	 */
	private String replaceNumbersByReoNameInTheModel(int[] model,
			Map<String, String> conditionIds, boolean hideFalses,
			boolean hideConditions) {
		String res = "";
		for (int d : model) {
			String v = variableNoName.get(Math.abs(d));
			boolean cond = conditionIds!=null && conditionIds.containsKey(v);
			String temp = (cond) ? (((d<0)?Keyword.NOT:"")+conditionIds.get(v)) : ((useOrbital)?v:restoreNames(v, d<0));
			temp = (cond) ? (hideConditions ? "" : temp) : temp;
			temp = (!cond && hideFalses && d < 0) ? "" : temp;
			res += (temp.length() != 0) ? ((res.length() != 0) ? " & " : "")
					+ temp : "";
		}
		return res;
	}

	/**
	 * Reformat the result of Sat4J into a format acceptable by Reduce
	 * 
	 * @param model
	 *            : The array of models that satisfy the constraints
	 */
	private int replaceNumbersByNamesForReduce(int[] model,
			Map<String, String> conditionIds) {
		ArrayList<String> conds = new ArrayList<String>();
		for (int m : model) {
			int n = Math.abs(m);
			String name = variableNoName.get(n);
			if (conditionIds != null && conditionIds.containsKey(name)) {
				if (m > 0)
					conds.add(conditionIds.get(name));
				else if (m < 0)
					conds.add("not(" + conditionIds.get(name) + ")");
				else {
					System.err.println("Bad value");
					return -1;
				}
			}
		}
		String res = "";
		for (int i = 0; i < conds.size(); i++) {
			if (res.length() > 0)
				res += " and ";
			res += "(" + conds.get(i) + ")";
		}
		if (res.trim().length()==0)
			return -1;
		int loc = dataConstraints.indexOf(res);
		if (loc < 0) {
			dataConstraints.add(res);
			loc = dataConstraints.size() - 1;
		}
		return loc;
	}

	// Returns a set of valid solutions without redundancy
	private String validateSolution(String solution, boolean showDetailsOfNoFlow) {
		boolean noFlow = true;
		HashSet<String> validSolution = new HashSet<String>();
		String[] vars = solution.split("&");
		for (String var : vars) {
			var = var.trim();
			String posvar = var.replace(useOrbital?Keyword.SYM_NOT:Keyword.NOT, "");
			if (posvar.endsWith(Keyword.GIVRSN)) {
				String noncontextvarname = posvar.substring(0,
						posvar.length() - 3);
				// Do not add the reason if there is a flow
			//	if (!solution.contains(noncontextvarname + " ")
				//		&& !solution.contains(noncontextvarname + "&")) {
				//	validSolution.add(var);
			//TODO	}
			} else {
				noFlow = false;
				// if the variable is not negative, the context variables should
				// be remmoved
				if (!var.startsWith("not ") && !var.startsWith("!")) { // TODO
																		
					validSolution.remove(var + "src");
					validSolution.remove(var + "snk");
				}
				validSolution.add(var);
			}
		}
		String res = ((showDetailsOfNoFlow) ? validSolution.toString()
				: ((noFlow) ? StateManager.NOFLOW : validSolution.toString()));
		return res.replaceAll("\\[|\\]", "");
	}

	private String restoreNames(String temp, boolean negative){
		String oldName = newOldNames.get(temp.toUpperCase());
		if (reducedNames != null&&reducedNames.containsKey(oldName)){	
			HashSet<String> oldnames = reducedNames.get(oldName);
			String res = "";
			for (String oldie:oldnames){
				res += ((res.length()>0)?" & ":"")+((negative) ? " not " : "") + oldie;
			}
			oldName = res;			
		}else{
			oldName = ((negative) ? " not " : "") + oldName;
		}
		return oldName;		
	}

	/**
	 * Solves a CNF boolean formula using Sat4J
	 * NO STATE TRANSITION
	 * @param cnfFileName
	 *            : The name of cnfFile
	 */
	public void solveSATFormula4test(File cnfFile, boolean hideFalses, boolean hideConditions, boolean showNOFLOWDetaiks) {
		System.out.println("CNF format is written in the file:"+cnfFile.getAbsolutePath());
		ISolver solver = SolverFactory.newDefault();
		ModelIterator mi = new ModelIterator(solver);
		solver.setTimeout(3600); // 1 hour timeout
		Reader reader = new InstanceReader(mi);
		int lcnt = 0;
		try {
			IProblem problem = reader.parseInstance(cnfFile.getAbsolutePath());
			while (problem.isSatisfiable()) {
				int[] model = problem.model();
				++lcnt;
				String temp = replaceNumbersByReoNameInTheModel(model,
						null, hideFalses, hideConditions);
				temp = validateSolution(temp, showNOFLOWDetaiks);
				System.out.println("Saat4J :" + lcnt + " :" + temp);

				int nxtStateIdx = 0;
				int condAnswIdx = replaceNumbersByNamesForReduce(model,
							null);
					Solution sol = new Solution(temp, condAnswIdx,						0, nxtStateIdx);
					int redundantSolutionIdx = solutions.indexOf(sol);
					if (redundantSolutionIdx < 0) {
						// saveResults
						solutions.add(sol);
					}
			}
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Timeout, sorry!");
		}
	}

}
